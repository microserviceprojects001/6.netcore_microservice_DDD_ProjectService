# 有关聚合根,以及里面的值对象我想深入理解一下，

比方说你的举例聚合根 - Order 描述的是订单，这其实就是一个边界了哈？然后

```
private List<OrderItem> orderItems; // 内部实体

private Address shippingAddress;       // 值对象
```

这两个 内部实体和值对象有什么区别吗？他们都是有单独的数据库表对应的吗？

内部实体（如 OrderItem）通常会有自己的表，而值对象（如 Address）通常嵌入在订单表中。
方案 1：最常用的方式（90%项目）

```
-- 订单表（聚合根）
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    customer_id BIGINT,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),
    created_at TIMESTAMP
);

-- 订单项表（内部实体）- 有自己的表
CREATE TABLE order_items (
    id BIGINT PRIMARY KEY,
    order_id BIGINT NOT NULL,  -- 外键关联订单
    product_id BIGINT NOT NULL,
    product_name VARCHAR(100),
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2),
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE
);

-- 地址信息（值对象）- 嵌入订单表
-- 直接在orders表中添加这些列：
-- shipping_province VARCHAR(50),
-- shipping_city VARCHAR(50),
-- shipping_address VARCHAR(200),
-- recipient_name VARCHAR(50),
-- recipient_phone VARCHAR(20)
```

# 地址信息（值对象），是没有单独的表的哈，那我想知道 什么叫做 内部实体，什么才叫做值对象呀，太不清晰了

## 真正的区别标准

## 值对象（Value Object）的特征：

- 没有概念上的标识：通过属性值来定义身份

- 不可变：创建后就不能修改

- 可替换：需要"修改"时就创建新的替换旧的

- 描述性的：描述某个事物的特征、属性

## 内部实体（Entity）的特征：

- 有标识：有唯一 ID 或通过关键属性标识

- 可变：可以修改属性而保持身份不变

- 有生命周期：在聚合内有独立的创建、修改、删除

- 有行为：有自己的业务逻辑和方法

# 🎯 重新理解 Order 例子

场景分析：电商订单

1. 地址信息（值对象）

```
public class Address {
    private final String province;
    private final String city;
    private final String street;
    private final String zipCode;

    // 行为：验证地址有效性
    public boolean isValid() {
        return province != null && city != null && !street.isEmpty();
    }

    // 如果需要"修改"，就创建新的
    public Address withNewStreet(String newStreet) {
        return new Address(this.province, this.city, newStreet, this.zipCode);
    }
}
```

## 为什么是值对象？

"北京市海淀区中关村大街 1 号" 和 "北京市海淀区中关村大街 1 号" 是同一个地址

如果用户要改地址，我们不是修改现有地址，而是整个替换成新地址

业务上不关心"这个地址对象的历史"，只关心"当前是什么地址"

2. 订单项（内部实体）

```
public class OrderItem {
    private OrderItemId id;        // 或者用 productId 作为标识
    private ProductId productId;
    private String productName;
    private int quantity;
    private Money price;

    // 行为：修改数量
    public void updateQuantity(int newQuantity) {
        if (newQuantity <= 0) {
            throw new InvalidQuantityException("数量必须大于0");
        }
        this.quantity = newQuantity;
        // 注意：这里修改了属性，但订单项的身份没变！
    }

    // 行为：应用折扣
    public void applyDiscount(Percentage discount) {
        this.price = this.price.applyDiscount(discount);
    }
}
```

## 为什么是内部实体？

即使把数量从 2 改成 3，它还是同一个订单项

在订单内，可能需要单独操作某个订单项（修改数量、应用折扣）

有独立的业务逻辑和状态变化

#🔍 更清晰的判断方法

问自己这些问题：

## 判断值对象：

问题 1：如果所有属性值都相同，是不是同一个东西？ ✅

问题 2：需不需要跟踪这个对象的个体变化？ ❌

问题 3：修改时是替换整个对象，还是修改部分属性？ 🔄 替换

## 判断内部实体：

问题 1：即使属性改变了，还是不是同一个东西？ ✅

问题 2：需不需要单独标识和引用这个对象？ ✅

问题 3：有没有独立的行为和生命周期？ ✅

# 值对象的数据是直接跟 Order 用同一个表中吗，不需要单独建表吗

简单直接的答案
是的，值对象的数据通常直接存储在聚合根的表中，不需要单独建表。 这是最常见的做法。
🗄️ 值对象的存储方式
方案一：嵌入同一张表（最推荐、最常用）

```
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    customer_id BIGINT,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),

    -- 地址值对象直接作为列嵌入
    shipping_province VARCHAR(50),
    shipping_city VARCHAR(50),
    shipping_street VARCHAR(200),
    shipping_zipcode VARCHAR(20),
    recipient_name VARCHAR(50),
    recipient_phone VARCHAR(20),

    created_at TIMESTAMP
);
```

代码中的映射：

```
// Order聚合根
public class Order {
    private OrderId id;
    private CustomerId customerId;
    private OrderStatus status;
    private Address shippingAddress;  // 值对象
    private List<OrderItem> orderItems;

    // 构造函数等...
}

// 值对象 - 没有自己的表
public class Address {
    private final String province;
    private final String city;
    private final String street;
    private final String zipCode;
    private final String recipientName;
    private final String recipientPhone;

    // 构造函数、equals、hashCode等...
}
```

Repository 实现：

```
@Repository
public class OrderRepositoryImpl implements OrderRepository {

    public Order findById(OrderId id) {
        String sql = "SELECT id, customer_id, status, " +
                    "shipping_province, shipping_city, shipping_street, " +
                    "shipping_zipcode, recipient_name, recipient_phone " +
                    "FROM orders WHERE id = ?";

        return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
            // 从同一行数据中构造值对象
            Address address = new Address(
                rs.getString("shipping_province"),
                rs.getString("shipping_city"),
                rs.getString("shipping_street"),
                rs.getString("shipping_zipcode"),
                rs.getString("recipient_name"),
                rs.getString("recipient_phone")
            );

            return new Order(
                new OrderId(rs.getLong("id")),
                new CustomerId(rs.getLong("customer_id")),
                OrderStatus.valueOf(rs.getString("status")),
                address,  // 值对象
                // ... 其他字段
            );
        }, id.getValue());
    }
}
```

# 🤔 为什么值对象不需要单独表？

## 业务角度：

整体性：地址总是作为订单的一部分被使用

不可变性：修改地址就是创建新订单或替换整个地址

无独立查询：很少会单独查询"所有北京市的配送地址"

## 技术角度：

性能：避免 JOIN 操作

一致性：保证数据在同一事务中

简单性：减少表数量和维护成本

# 好，那如果有多个地址呢 shippingAddress

private Address shippingAddress; 比方说需要定义成 private List<Address> shippingAddress; 了

地址列表（动态多个地址）
业务场景：
一个订单需要配送到多个地点

分批发货

不同商品发往不同地址

数据库设计：JSON 存储

```
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    customer_id BIGINT,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),

    -- 多个地址作为JSON存储
    shipping_addresses JSON,

    created_at TIMESTAMP
);

-- JSON结构示例：
-- [
--   {
--     "type": "MAIN",
--     "province": "北京市",
--     "city": "北京市",
--     "street": "海淀区中关村大街1号",
--     "zipCode": "100080",
--     "recipient": "张三",
--     "phone": "13800138000"
--   },
--   {
--     "type": "GIFT",
--     "province": "上海市",
--     "city": "上海市",
--     "street": "浦东新区陆家嘴环路1000号",
--     "zipCode": "200120",
--     "recipient": "李四",
--     "phone": "13900139000"
--   }
-- ]
```

## 领域模型：

1. 领域模型设计

```
public class Order {
    private OrderId id;
    private CustomerId customerId;
    private OrderStatus status;
    private List<ShippingAddress> shippingAddresses;  // 地址列表
    private List<OrderItem> orderItems;

    // 值对象 - 带元数据的配送地址
    public static class ShippingAddress {
        private final AddressType type;        // 地址类型
        private final Address address;         // 地址详情
        private final String recipient;        // 收件人
        private final String phone;            // 联系电话
        private final boolean isDefault;       // 是否默认地址

        public ShippingAddress(AddressType type, Address address,
                             String recipient, String phone, boolean isDefault) {
            this.type = type;
            this.address = address;
            this.recipient = recipient;
            this.phone = phone;
            this.isDefault = isDefault;
        }

        // getters...
    }

    public enum AddressType {
        MAIN,           // 主配送地址
        GIFT,           // 礼品地址
        OFFICE,         // 办公室地址
        WAREHOUSE,      // 仓库地址
        PICKUP_POINT    // 自提点
    }

    // 业务方法
    public void addShippingAddress(AddressType type, Address address,
                                 String recipient, String phone, boolean isDefault) {
        // 如果设置为默认地址，先取消其他默认地址
        if (isDefault) {
            shippingAddresses.forEach(addr -> addr.isDefault = false);
        }

        ShippingAddress newAddress = new ShippingAddress(type, address, recipient, phone, isDefault);
        this.shippingAddresses.add(newAddress);
    }

    public void removeShippingAddress(AddressType type) {
        shippingAddresses.removeIf(addr -> addr.getType() == type);
    }

    public Optional<ShippingAddress> getDefaultShippingAddress() {
        return shippingAddresses.stream()
            .filter(ShippingAddress::isDefault)
            .findFirst();
    }

    public List<ShippingAddress> getShippingAddressesByType(AddressType type) {
        return shippingAddresses.stream()
            .filter(addr -> addr.getType() == type)
            .collect(Collectors.toList());
    }
}
```

2. 数据库设计 - JSON 存储

```
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    customer_id BIGINT,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),

    -- 多个地址作为JSON存储
    shipping_addresses JSON,

    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- JSON结构示例：
/*
[
  {
    "type": "MAIN",
    "isDefault": true,
    "recipient": "张三",
    "phone": "13800138000",
    "address": {
      "province": "北京市",
      "city": "北京市",
      "district": "海淀区",
      "street": "中关村大街1号",
      "zipCode": "100080"
    }
  },
  {
    "type": "GIFT",
    "isDefault": false,
    "recipient": "李四",
    "phone": "13900139000",
    "address": {
      "province": "上海市",
      "city": "上海市",
      "district": "浦东新区",
      "street": "陆家嘴环路1000号",
      "zipCode": "200120"
    }
  }
]
*/
```

3. Repository 实现

```
@Repository
public class OrderRepositoryImpl implements OrderRepository {

    private final JdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;

    public Order findById(OrderId id) {
        String sql = "SELECT id, customer_id, status, shipping_addresses, created_at " +
                    "FROM orders WHERE id = ?";

        return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
            Order order = new Order(
                new OrderId(rs.getLong("id")),
                new CustomerId(rs.getLong("customer_id")),
                OrderStatus.valueOf(rs.getString("status"))
            );

            // 解析JSON地址列表
            String addressesJson = rs.getString("shipping_addresses");
            if (addressesJson != null) {
                List<Order.ShippingAddress> addresses = parseAddresses(addressesJson);
                order.setShippingAddresses(addresses);
            }

            return order;
        }, id.getValue());
    }

    public void save(Order order) {
        String sql = "INSERT INTO orders (id, customer_id, status, shipping_addresses, created_at) " +
                    "VALUES (?, ?, ?, ?, ?) " +
                    "ON DUPLICATE KEY UPDATE status = ?, shipping_addresses = ?, updated_at = ?";

        String addressesJson = serializeAddresses(order.getShippingAddresses());

        jdbcTemplate.update(sql,
            order.getId().getValue(),
            order.getCustomerId().getValue(),
            order.getStatus().name(),
            addressesJson,
            order.getCreatedAt(),
            order.getStatus().name(),
            addressesJson,
            LocalDateTime.now()
        );
    }

    private List<Order.ShippingAddress> parseAddresses(String json) {
        try {
            // 使用Jackson或其他JSON库解析
            return objectMapper.readValue(json,
                objectMapper.getTypeFactory().constructCollectionType(
                    List.class, Order.ShippingAddress.class));
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse addresses JSON", e);
        }
    }

    private String serializeAddresses(List<Order.ShippingAddress> addresses) {
        try {
            return objectMapper.writeValueAsString(addresses);
        } catch (Exception e) {
            throw new RuntimeException("Failed to serialize addresses", e);
        }
    }
}
```

4. 使用示例

```
// 创建订单并添加多个地址
Order order = Order.create(customerId);

// 添加主配送地址
order.addShippingAddress(
    AddressType.MAIN,
    new Address("北京市", "北京市", "海淀区", "中关村大街1号", "100080"),
    "张三",
    "13800138000",
    true
);

// 添加礼品地址
order.addShippingAddress(
    AddressType.GIFT,
    new Address("上海市", "上海市", "浦东新区", "陆家嘴环路1000号", "200120"),
    "李四",
    "13900139000",
    false
);

// 业务操作：获取默认配送地址
Order.ShippingAddress defaultAddress = order.getDefaultShippingAddress()
    .orElseThrow(() -> new NoShippingAddressException());

// 业务操作：按类型查询地址
List<Order.ShippingAddress> giftAddresses = order.getShippingAddressesByType(AddressType.GIFT);
```

5. 适用业务场景

这种设计适合：

- 礼品订单：商品配送到不同收件人

- 企业采购：配送到不同部门或分公司

- 分批发货：商品从不同仓库发货到不同地址

- 混合订单：部分商品配送到办公室，部分配送到家里
