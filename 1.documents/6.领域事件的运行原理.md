# 领域事件是会被持久化到数据库里面吗 ，

# 🚫 领域事件不会被持久化到数据库

```
var domainEvents = _context.ChangeTracker
    .Entries<Entity>()
    .SelectMany(x => x.Entity.DomainEvents)
    .ToList();
```

这不是从数据库查询，而是从 EF Core 的变更跟踪器中获取内存中的领域事件！

1. 领域事件的生命周期

```
// 步骤1：在领域对象中产生事件（内存中）
public class Order : Entity
{
    public void Pay()
    {
        Status = OrderStatus.Paid;
        // 在内存中添加领域事件
        AddDomainEvent(new OrderPaidEvent(Id, TotalAmount));
    }
}

// 步骤2：EF Core跟踪这些对象
var order = await _orderRepository.GetByIdAsync(orderId);  // EF Core开始跟踪
order.Pay();  // 产生 OrderPaidEvent，事件存储在 order.DomainEvents 中

// 步骤3：从变更跟踪器获取事件（不是从数据库！）
var domainEvents = _context.ChangeTracker
    .Entries<Entity>()  // 获取所有被跟踪的实体
    .SelectMany(x => x.Entity.DomainEvents)  // 从实体对象中提取事件
    .ToList();  // 在内存中创建事件列表
```

2. 内存中的数据结构

```
内存中的对象关系：
_context (ApplicationDbContext)
  ↓
ChangeTracker (跟踪所有实体状态变化)
  ↓
Entries<Entity> (所有被跟踪的实体对象)
  ↓
[Order对象1] → DomainEvents: [OrderCreatedEvent, OrderPaidEvent]
[Order对象2] → DomainEvents: [ShippingAddressChangedEvent]
[其他实体]   → DomainEvents: []
```

3. 完整的数据流

```
// 1. 应用服务调用
public async Task PayOrder(OrderId orderId)
{
    var order = await _orderRepository.GetByIdAsync(orderId);  // 从数据库加载
    order.Pay();  // 在内存中修改状态并添加事件

    // 此时：
    // - order对象在内存中
    // - OrderPaidEvent在order.DomainEvents中（内存）
    // - EF Core的ChangeTracker跟踪着order对象的变化

    await _orderRepository.SaveChangesAsync();  // 保存并发布事件
}

// 2. SaveChangesAsync内部
public async Task SaveChangesAsync(CancellationToken cancellationToken = default)
{
    // 从内存中的变更跟踪器获取事件
    var domainEvents = _context.ChangeTracker
        .Entries<Entity>()
        .SelectMany(x => x.Entity.DomainEvents)  // 从内存对象获取！
        .ToList();

    // 保存到数据库（领域事件不保存！）
    await _context.SaveChangesAsync(cancellationToken);

    // 发布内存中的事件
    foreach (var domainEvent in domainEvents)
    {
        await _domainEventPublisher.Publish(domainEvent, cancellationToken);
    }

    // 清空内存中的事件
    ClearDomainEvents();
}
```

[NotMapped] 特性明确表示：这个属性只存在于内存中，不应该映射到数据库表！

# 🎯 正确理解 ChangeTracker

ChangeTracker 的作用：

```
// ChangeTracker 是EF Core的内存管理器
// 它跟踪：哪些对象被加载、修改、添加、删除

var order = await _context.Orders.FindAsync(id);  // ChangeTracker开始跟踪
order.Status = OrderStatus.Paid;                  // ChangeTracker标记为Modified
order.AddDomainEvent(new OrderPaidEvent());       // 内存中添加事件（ChangeTracker知道）

// 从ChangeTracker获取的是内存中的对象引用，不是数据库数据！
var trackedOrder = _context.ChangeTracker.Entries<Order>().First();
var events = trackedOrder.Entity.DomainEvents;  // 从内存对象获取
```

# ✅ 总结

回答你的问题：领域事件不会被持久化到数据库！

来源：从 EF Core 的 ChangeTracker 获取内存中的事件

存储：事件只存在于内存中，处理完成后被丢弃

证据：[NotMapped] 特性明确阻止了数据库持久化

设计意图：领域事件是业务流程的副产品，不是需要持久化的核心数据

# 我有一个疑问，比方说一个用户在新建 order 会添加领域事件 ordercreated event，另一个用户在支付他的订单，会发布 OderPaiedEvent 领域事件，好嘞，

           var domainEvents = \_context.ChangeTracker

                .Entries<Entity>()
                .SelectMany(x => x.Entity.DomainEvents)
                .ToList();

            _logger.LogDebug("收集到 {EventCount} 个领域事件", domainEvents.Count);

            // 2. 保存数据变更
            await _context.SaveChangesAsync(cancellationToken);

            // 3. 发布领域事件
            if (domainEvents.Any())
            {
                await _domainEventPublisher.PublishAsync(domainEvents, cancellationToken);
            }

当他们各自调用了 savechange 方法，这个 publishasync 是发布了所有人的 Event 了吗，

# 非常好的问题！ 你的担心是有道理的，但答案是：不会发布所有人的事件，只会发布当前工作单元中的事件。

🎯 关键概念：DbContext 的工作单元模式
在典型的 Web 应用中，每个 HTTP 请求都会创建一个新的 DbContext 实例，这意味着：

```
// 用户A的请求
public class OrderController
{
    public async Task<IActionResult> CreateOrder()
    {
        using var scope = _serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        var repository = new OrderRepository(context, ...);

        // 用户A创建订单
        var orderA = Order.Create(...);
        await repository.AddAsync(orderA);
        await repository.SaveChangesAsync();  // 只发布orderA的事件
    }
}

// 用户B的请求（同时发生）
public class OrderController
{
    public async Task<IActionResult> PayOrder()
    {
        using var scope = _serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        var repository = new OrderRepository(context, ...);

        // 用户B支付订单
        var orderB = await repository.GetByIdAsync(...);
        orderB.Pay();
        await repository.SaveChangesAsync();  // 只发布orderB的事件
    }
}
```

🔍 详细分析你的场景
场景：两个用户同时操作

```
// 时间点 T1: 用户A开始创建订单
var contextA = new ApplicationDbContext();  // 创建DbContext实例A
var repositoryA = new OrderRepository(contextA, ...);

var orderA = Order.Create(customerA, address, items);
// orderA.DomainEvents: [OrderCreatedEvent]

await repositoryA.AddAsync(orderA);

// 时间点 T2: 用户B开始支付订单
var contextB = new ApplicationDbContext();  // 创建DbContext实例B
var repositoryB = new OrderRepository(contextB, ...);

var orderB = await repositoryB.GetByIdAsync(orderIdB);
orderB.Pay();
// orderB.DomainEvents: [OrderPaidEvent]

// 时间点 T3: 用户A保存
await repositoryA.SaveChangesAsync();
// contextA.ChangeTracker 只包含 orderA
// 发布: [OrderCreatedEvent] ← 只有用户A的事件！

// 时间点 T4: 用户B保存
await repositoryB.SaveChangesAsync();
// contextB.ChangeTracker 只包含 orderB
// 发布: [OrderPaidEvent] ← 只有用户B的事件！
```

🏗️ 依赖注入配置确保隔离

```
// Program.cs
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString),
    ServiceLifetime.Scoped  // 🎯 关键：每个请求一个实例
);

builder.Services.AddScoped<IOrderRepository, OrderRepository>();
```

🧪 验证隔离性
让我们通过代码验证：

```
[Test]
public async Task TwoConcurrentUsers_ShouldHaveIsolatedDomainEvents()
{
    // 模拟两个用户的DbContext
    var contextUserA = new ApplicationDbContext();
    var contextUserB = new ApplicationDbContext();

    var repoUserA = new OrderRepository(contextUserA, ...);
    var repoUserB = new OrderRepository(contextUserB, ...);

    // 用户A创建订单
    var orderA = Order.Create(customerA, address, items);
    await repoUserA.AddAsync(orderA);

    // 用户B支付订单
    var orderB = await repoUserB.GetByIdAsync(existingOrderId);
    orderB.Pay();

    // 验证各自ChangeTracker的内容
    var eventsUserA = contextUserA.ChangeTracker
        .Entries<Entity>()
        .SelectMany(e => e.Entity.DomainEvents)
        .ToList();

    var eventsUserB = contextUserB.ChangeTracker
        .Entries<Entity>()
        .SelectMany(e => e.Entity.DomainEvents)
        .ToList();

    // 断言：各自只有自己的事件
    Assert.That(eventsUserA, Has.Exactly(1).Items);      // 只有OrderCreatedEvent
    Assert.That(eventsUserB, Has.Exactly(1).Items);      // 只有OrderPaidEvent
    Assert.That(eventsUserA[0], Is.TypeOf<OrderCreatedEvent>());
    Assert.That(eventsUserB[0], Is.TypeOf<OrderPaidEvent>());
}
```
