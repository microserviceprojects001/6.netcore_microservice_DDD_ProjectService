# 结合业务需求来认识各种名称

```
  界限上下文
  实体
  值对象
  聚合
  聚合根
  仓储-持久化
```

![alt text](<../截图/0.DDD工作流程 .png>)

1. 界限上下文 - Bounded Context

## 核心思想

大型系统被划分为多个相对独立的业务边界，每个边界内有自己的领域模型和通用语言

## 生动比喻

想象一个医院：

- 挂号科：病人 = {姓名, 症状, 挂号时间}

- 药房：病人 = {姓名, 药品清单, 过敏史}

- 财务科：病人 = {姓名, 账户余额, 缴费记录}

每个科室对"病人"的理解不同，这就是不同的界限上下文。

## 实际案例：电商系统

```
// 商品上下文 - 关注商品信息
public class Product {
    private ProductId id;
    private String name;
    private Price price;
    private Inventory inventory;
}

// 订单上下文 - 关注购买流程
public class Order {
    private OrderId id;
    private List<OrderItem> items;
    private OrderStatus status;
}
```

2. 实体 - Entity

## 核心特征

- 有唯一标识：通过 ID 区分不同对象

- 有生命周期：会经历状态变化

- 可变：属性可以修改

例子

```
public class User {
    private UserId id;      // 唯一标识
    private String name;    // 可修改
    private String email;   // 可修改

    // 行为方法
    public void changeEmail(String newEmail) {
        // 业务规则验证
        if (!isValidEmail(newEmail)) {
            throw new InvalidEmailException();
        }
        this.email = newEmail;
    }
}

```

3. 值对象 - Value Object

## 核心特征

- 无唯一标识：通过所有属性值来区分

- 不可变：创建后不能修改

- 可替换：直接替换整个对象
  例子

```
public class Address {
    private final String province;  // final表示不可变
    private final String city;
    private final String street;
    private final String zipCode;

    // 基于所有属性判断相等性
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Address address = (Address) o;
        return Objects.equals(province, address.province) &&
               Objects.equals(city, address.city) &&
               Objects.equals(street, address.street) &&
               Objects.equals(zipCode, address.zipCode);
    }
}
```

🎯 4. 聚合 - Aggregate & 聚合根 - Aggregate Root
这是 DDD 中最关键的概念！

## 核心思想

将高度相关的对象组合在一起，形成一个一致性边界

## 想象一个订单：

- 订单本身（聚合根）

- 订单项（内部实体）

- 配送地址（值对象）
  外部只能通过"订单"来操作里面的所有东西，不能直接操作订单项。

## 代码示例

```
// 聚合根 - Order
// 聚合根
public class Order {
    private OrderId id;
    private CustomerId customerId;
    private OrderStatus status;
    private Address shippingAddress;     // 值对象
    private List<OrderItem> orderItems;  // 内部实体列表

    // 业务方法：更新配送地址（值对象替换）
    public void changeShippingAddress(Address newAddress) {
        // 业务规则验证
        if (this.status == OrderStatus.SHIPPED) {
            throw new OrderAlreadyShippedException();
        }
        // 整体替换值对象
        this.shippingAddress = newAddress;
    }

    // 业务方法：添加订单项（内部实体操作）
    public void addOrderItem(ProductId productId, int quantity, Money price) {
        // 业务规则验证
        if (this.status != OrderStatus.CREATED) {
            throw new OrderCannotBeModifiedException();
        }

        // 检查是否已存在
        Optional<OrderItem> existing = findOrderItemByProduct(productId);
        if (existing.isPresent()) {
            existing.get().updateQuantity(quantity);
        } else {
            OrderItem newItem = OrderItem.create(productId, quantity, price);
            this.orderItems.add(newItem);
        }

        // 维护聚合内的一致性
        this.ensureOrderInvariant();
    }

    // 私有方法：查找内部实体
    private Optional<OrderItem> findOrderItemByProduct(ProductId productId) {
        return orderItems.stream()
            .filter(item -> item.getProductId().equals(productId))
            .findFirst();
    }
}

// 值对象 - Address
public class Address {
    private final String province;
    private final String city;
    private final String street;
    private final String zipCode;

    public Address(String province, String city, String street, String zipCode) {
        this.province = province;
        this.city = city;
        this.street = street;
        this.zipCode = zipCode;
    }

    // 值对象相等性比较
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Address)) return false;
        Address address = (Address) o;
        return Objects.equals(province, address.province) &&
               Objects.equals(city, address.city) &&
               Objects.equals(street, address.street) &&
               Objects.equals(zipCode, address.zipCode);
    }
}

// 内部实体 - OrderItem
public class OrderItem {
    private OrderItemId id;
    private ProductId productId;
    private int quantity;
    private Money price;

    // 内部实体可以有自己的行为
    public void updateQuantity(int newQuantity) {
        if (newQuantity <= 0) {
            throw new InvalidQuantityException();
        }
        this.quantity = newQuantity;
    }
}
```

## 聚合的重要规则：

- 聚合根是唯一入口：外部只能通过聚合根来访问聚合内部

- 引用其他聚合：只能通过 ID 引用，不能直接持有对象引用

- 事务边界：一个聚合就是一个事务边界

- 整体保存：保存聚合时，整个聚合一起保存

5. 仓储 - Repository

## 核心职责

只针对聚合根进行持久化操作

## 例子

```
// 仓储接口 - 在领域层定义
public interface OrderRepository {
    // 只处理聚合根Order
    Optional<Order> findById(OrderId id);
    void save(Order order);
    void delete(Order order);

    // 不会出现这样的方法！
    // ❌ void saveOrderItem(OrderItem item) - 错误！
}

// 应用服务中使用
public class OrderApplicationService {
    private OrderRepository orderRepository;

    public void addItemToOrder(OrderId orderId, ProductId productId, int quantity) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException());

        // 通过聚合根操作
        order.addItem(productId, quantity, productService.getPrice(productId));

        // 保存整个聚合
        orderRepository.save(order);
    }
}
```

6. 领域事件 - Domain Event

## 核心特征

- 表示已发生的事情

- 包含业务意义

- 可被其他组件监听

## 例子

```
public class OrderPaidEvent {
    private final OrderId orderId;
    private final CustomerId customerId;
    private final Money amount;
    private final Instant occurredOn;

    public OrderPaidEvent(OrderId orderId, CustomerId customerId, Money amount) {
        this.orderId = orderId;
        this.customerId = customerId;
        this.amount = amount;
        this.occurredOn = Instant.now();
    }
}

// 在聚合中发布事件
public class Order {
    public void pay(Payment payment) {
        this.status = OrderStatus.PAID;
        this.paymentTime = Instant.now();

        // 发布领域事件
        this.addDomainEvent(new OrderPaidEvent(this.id, this.customerId, this.totalAmount));
    }
}
```
